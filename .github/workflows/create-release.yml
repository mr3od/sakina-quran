name: Create Release

on:
  push:
    branches:
      - main
      - development

permissions:
  contents: write

jobs:
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Read version from app.json
        id: version
        run: |
          VERSION=$(jq -r '.expo.version' app.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          echo "Tag: v$VERSION"
      
      - name: Check if release exists
        id: check-release
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          BRANCH="${{ github.ref_name }}"
          
          # Check if tag exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Check if we should update (main promotion)
            if [ "$BRANCH" = "main" ]; then
              echo "should_update=true" >> $GITHUB_OUTPUT
              echo "üîÑ Release $TAG exists, will update for production deployment"
            else
              echo "should_update=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Release $TAG already exists on development, skipping"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "should_update=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Release $TAG does not exist, will create"
          fi
      
      - name: Get previous release tag
        id: previous-tag
        if: steps.check-release.outputs.exists == 'false' || steps.check-release.outputs.should_update == 'true'
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          BRANCH="${{ github.ref_name }}"
          
          # If updating existing release (promotion to main), get the tag before current
          if [ "${{ steps.check-release.outputs.should_update }}" = "true" ]; then
            # Get all tags sorted, find the one before current tag
            PREVIOUS_TAG=$(git tag -l --sort=-v:refname | grep -A1 "^${TAG}$" | tail -1)
            if [ "$PREVIOUS_TAG" = "$TAG" ] || [ -z "$PREVIOUS_TAG" ]; then
              # No previous tag found, use initial commit
              PREVIOUS_TAG=""
            fi
          else
            # Creating new release, get latest existing tag
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          fi
          
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "tag=" >> $GITHUB_OUTPUT
            echo "No previous release found"
          else
            echo "tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
            echo "Previous release: $PREVIOUS_TAG"
          fi
      
      - name: Generate changelog
        id: changelog
        if: steps.check-release.outputs.exists == 'false' || steps.check-release.outputs.should_update == 'true'
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          PREVIOUS_TAG="${{ steps.previous-tag.outputs.tag }}"
          BRANCH="${{ github.ref_name }}"
          
          echo "Generating changelog..."
          echo "Current tag: $TAG"
          echo "Previous tag: $PREVIOUS_TAG"
          echo "Branch: $BRANCH"
          
          # Get commits for changelog
          if [ "${{ steps.check-release.outputs.should_update }}" = "true" ]; then
            # Updating existing release (promotion to main)
            # Get commits since previous tag (not current tag)
            if [ -z "$PREVIOUS_TAG" ]; then
              COMMITS=$(git log --pretty=format:"%s|%an|%h" --no-merges)
            else
              COMMITS=$(git log ${PREVIOUS_TAG}..${TAG} --pretty=format:"%s|%an|%h" --no-merges)
            fi
          else
            # Creating new release
            if [ -z "$PREVIOUS_TAG" ]; then
              COMMITS=$(git log --pretty=format:"%s|%an|%h" --no-merges)
            else
              COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"%s|%an|%h" --no-merges)
            fi
          fi
          
          # Initialize changelog sections
          FEATURES=""
          FIXES=""
          CHORES=""
          DOCS=""
          OTHER=""
          
          # Parse commits and group by type
          while IFS='|' read -r message author hash; do
            [ -z "$message" ] && continue
            
            # Extract type from conventional commit format
            if [[ $message =~ ^feat(\(.+\))?:\ (.+)$ ]]; then
              FEATURES="${FEATURES}- ${BASH_REMATCH[2]} (${hash}) by @${author}\n"
            elif [[ $message =~ ^fix(\(.+\))?:\ (.+)$ ]]; then
              FIXES="${FIXES}- ${BASH_REMATCH[2]} (${hash}) by @${author}\n"
            elif [[ $message =~ ^chore(\(.+\))?:\ (.+)$ ]]; then
              CHORES="${CHORES}- ${BASH_REMATCH[2]} (${hash}) by @${author}\n"
            elif [[ $message =~ ^docs(\(.+\))?:\ (.+)$ ]]; then
              DOCS="${DOCS}- ${BASH_REMATCH[2]} (${hash}) by @${author}\n"
            else
              OTHER="${OTHER}- ${message} (${hash}) by @${author}\n"
            fi
          done <<< "$COMMITS"
          
          # Build changelog
          CHANGELOG="## Changes\n\n"
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### ‚ú® Features\n${FEATURES}\n"
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### üêõ Bug Fixes\n${FIXES}\n"
          fi
          
          if [ -n "$CHORES" ]; then
            CHANGELOG="${CHANGELOG}### üîß Chores\n${CHORES}\n"
          fi
          
          if [ -n "$DOCS" ]; then
            CHANGELOG="${CHANGELOG}### üìö Documentation\n${DOCS}\n"
          fi
          
          if [ -n "$OTHER" ]; then
            CHANGELOG="${CHANGELOG}### üì¶ Other Changes\n${OTHER}\n"
          fi
          
          # Save to file
          echo -e "$CHANGELOG" > changelog.md
          echo "Changelog generated successfully"
          echo "--- Changelog Preview ---"
          cat changelog.md
          echo "--- End Preview ---"
      
      - name: Determine release type
        id: release-type
        if: steps.check-release.outputs.exists == 'false' || steps.check-release.outputs.should_update == 'true'
        run: |
          BRANCH="${{ github.ref_name }}"
          if [ "$BRANCH" = "main" ]; then
            echo "prerelease=false" >> $GITHUB_OUTPUT
            echo "üì¶ Creating full release (production branch)"
          else
            echo "prerelease=true" >> $GITHUB_OUTPUT
            echo "üöß Creating pre-release (development branch)"
          fi
      
      - name: Create GitHub Release
        if: steps.check-release.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          VERSION="${{ steps.version.outputs.version }}"
          IS_PRERELEASE="${{ steps.release-type.outputs.prerelease }}"
          BRANCH="${{ github.ref_name }}"
          
          # Create release using GitHub CLI
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release create "$TAG" \
              --title "Release $VERSION" \
              --notes-file changelog.md \
              --prerelease
          else
            gh release create "$TAG" \
              --title "Release $VERSION" \
              --notes-file changelog.md \
              --latest
          fi
          
          echo "‚úÖ Release $TAG created successfully!"
      
      - name: Update existing release
        if: steps.check-release.outputs.should_update == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          VERSION="${{ steps.version.outputs.version }}"
          IS_PRERELEASE="${{ steps.release-type.outputs.prerelease }}"
          
          # Update release using GitHub CLI
          # When promoting to production, we need to explicitly set --prerelease=false
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release edit "$TAG" \
              --title "Release $VERSION" \
              --notes-file changelog.md \
              --prerelease
          else
            # Promoting to production: remove prerelease flag and mark as latest
            gh release edit "$TAG" \
              --title "Release $VERSION" \
              --notes-file changelog.md \
              --prerelease=false \
              --latest
          fi
          
          echo "‚úÖ Release $TAG updated successfully!"
      
      - name: Release summary
        if: steps.check-release.outputs.exists == 'false' || steps.check-release.outputs.should_update == 'true'
        run: |
          BRANCH="${{ github.ref_name }}"
          IS_PRERELEASE="${{ steps.release-type.outputs.prerelease }}"
          TAG="v${{ steps.version.outputs.version }}"
          
          if [ "${{ steps.check-release.outputs.exists }}" = "true" ]; then
            echo "üîÑ Release $TAG updated for $BRANCH deployment"
          else
            echo "‚úÖ Release $TAG created successfully!"
          fi
          
          echo "üìù Changelog has been generated and included in the release notes"
          
          if [ "$IS_PRERELEASE" = "true" ]; then
            echo "üöß Release is marked as pre-release (deployed to development)"
          else
            echo "üì¶ Release is marked as full release (deployed to production)"
          fi
